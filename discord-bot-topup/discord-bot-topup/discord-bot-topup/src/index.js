// src/index.js (Full Code - ‡πÄ‡∏≠‡∏≤ ScoreboardManager ‡∏≠‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
import { Client, GatewayIntentBits } from "discord.js";
import configService from "./services/configService.js";
import databaseService from "./services/databaseService.js";
import webhookService from "./services/webhookService.js";
import TopupSystem from "./components/topupSystem.js";
// ‚ùå ‡πÄ‡∏≠‡∏≤‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å: import ScoreboardManager from "./components/scoreboardManager.js";
import rconManager from "./components/rconManager.js";
import logService from "./services/logService.js";
import slipVerification from "./components/slipVerification.js";

// Import new utilities
import ErrorHandler from "./utils/errorHandler.js";
import DebugHelper from "./utils/debugHelper.js";
import ResponseHelper from "./utils/responseHelper.js";

class DiscordBot {
  constructor() {
    this.client = null;
    this.topupSystem = null;
    // ‚ùå ‡πÄ‡∏≠‡∏≤‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å: this.scoreboardManager = null;
    this.isShuttingDown = false;
  }

  async init() {
    try {
      DebugHelper.info("Starting NEXArk Discord Bot...");

      // Test and load configuration
      await this.initializeConfiguration();

      // Initialize Discord client
      await this.initializeDiscordClient();

      // Initialize database
      await this.initializeDatabase();

      // Test services
      await this.testServices();

      // Setup event listeners
      this.setupEventListeners();

      // Login bot
      await this.loginBot();

      logService.info("NEXArk Discord Bot started successfully");
    } catch (error) {
      DebugHelper.error("Bot startup failed:", error);
      logService.error("Failed to start NEXArk Discord Bot:", error);
      process.exit(1);
    }
  }

  async initializeConfiguration() {
    DebugHelper.info("Testing configuration file...");
    const configTest = await configService.testConfigFile();
    if (!configTest.success) {
      throw new Error(`Config file test failed: ${configTest.error}`);
    }

    DebugHelper.info("Loading configuration...");
    await configService.loadConfig();

    // Validate configuration
    const validation = configService.validateConfig();
    if (!validation.isValid) {
      const criticalErrors = validation.errors.filter(
        (error) =>
          !error.includes("RCON") &&
          !error.includes("webhook") &&
          !error.includes("EasySlip")
      );

      if (criticalErrors.length > 0) {
        throw new Error(
          `Critical configuration errors: ${criticalErrors.join(", ")}`
        );
      } else {
        DebugHelper.warn("Non-critical configuration warnings detected");
      }
    }

    // Reinitialize services with new config
    webhookService.reloadConfig();
    rconManager.reloadConfig();

    DebugHelper.info("Configuration loaded and services reinitialized");
  }

  async testServices() {
    DebugHelper.info("Testing services...");

    // Test Slip Verification Service
    console.log("\nüîç Testing Slip Verification Service...");
    const slipVerificationStatus = slipVerification.getServiceStatus();
    console.log("Slip Verification Status:", slipVerificationStatus);
    
    if (!slipVerificationStatus.enabled) {
      DebugHelper.warn("‚ö†Ô∏è EasySlip API is DISABLED - using basic validation mode");
      DebugHelper.warn("‚ö†Ô∏è This will use basic file validation instead of real slip verification!");
    } else {
      DebugHelper.info("‚úÖ EasySlip API is ENABLED and configured properly");
    }

    // Test webhook
    const webhookStatus = webhookService.getServiceStatus();
    if (webhookStatus.enabled && webhookStatus.webhookUrlValid) {
      const webhookTest = await webhookService.testWebhook();
      if (webhookTest.success) {
        DebugHelper.info("Discord webhook test successful");
      } else {
        DebugHelper.warn("Discord webhook test failed:", webhookTest.error);
      }
    }

    // Test RCON
    const rconConfig = rconManager.getConfiguration();
    if (rconConfig.totalServers > 0) {
      const testResults = await rconManager.testAllServers();
      DebugHelper.info(
        `RCON test results: ${testResults.successful}/${testResults.total} servers responding`
      );
    }
  }

  async initializeDiscordClient() {
    DebugHelper.info("Initializing Discord client...");

    this.client = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.DirectMessages,
      ],
      allowedMentions: {
        parse: ["users", "roles"],
        repliedUser: false,
      },
    });

    // Initialize systems
    this.topupSystem = new TopupSystem(this.client);
    // ‚ùå ‡πÄ‡∏≠‡∏≤‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å: this.scoreboardManager = new ScoreboardManager(this.client);
  }

  async initializeDatabase() {
    DebugHelper.info("Connecting to database...");
    await databaseService.connect();
    await databaseService.createTables();
    DebugHelper.info("Database connected and tables created");
  }

  setupEventListeners() {
    // Bot ready event
    this.client.once("ready", async () => {
      DebugHelper.info(`Bot ready! Logged in as ${this.client.user.tag}`);
      DebugHelper.info(
        `Connected to ${this.client.guilds.cache.size} guild(s)`
      );

      // Set bot status
      this.client.user.setActivity("NEXArk Donation System", {
        type: "WATCHING",
      });

      try {
        await this.topupSystem.init();
        // ‚ùå ‡πÄ‡∏≠‡∏≤‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å: await this.scoreboardManager.init();

        DebugHelper.info("All systems initialized successfully!");

        // Send startup notification
        if (webhookService.getServiceStatus().enabled) {
          await this.sendStartupNotification();
        }
      } catch (error) {
        DebugHelper.error("System initialization failed:", error);
      }
    });

    // Interaction handler
    this.client.on("interactionCreate", async (interaction) => {
      if (this.isShuttingDown) {
        await ResponseHelper.safeReply(
          interaction,
          "üîÑ ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà"
        );
        return;
      }

      try {
        if (interaction.isButton()) {
          DebugHelper.log("Button interaction received in main handler", {
            customId: interaction.customId,
            userId: interaction.user.id,
          });

          // ‚ùå ‡πÄ‡∏≠‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å:
          // if (interaction.customId.startsWith("scoreboard_")) {
          //   await this.scoreboardManager.handleScoreboardNavigation(
          //     interaction
          //   );
          // } else {
          //   await this.topupSystem.handleButtonInteraction(interaction);
          // }

          // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÄ‡∏õ‡πá‡∏ô:
          await this.topupSystem.handleButtonInteraction(interaction);
        } else if (interaction.isStringSelectMenu()) {
          await this.topupSystem.handleSelectMenuInteraction(interaction);
        } else if (interaction.isModalSubmit()) {
          await this.topupSystem.handleModalSubmit(interaction);
        } else if (interaction.isChatInputCommand()) {
          await this.handleSlashCommands(interaction);
        }
      } catch (error) {
        await ErrorHandler.handleInteractionError(
          error,
          interaction,
          "General Interaction"
        );
      }
    });

    // Message handler
    this.client.on("messageCreate", async (message) => {
      if (message.author.bot || this.isShuttingDown) return;

      try {
        if (
          message.channel.name &&
          (message.channel.name.startsWith("topup-") ||
            message.channel.name.startsWith("support-"))
        ) {
          await this.topupSystem.handleSlipSubmission(message);
        }
      } catch (error) {
        DebugHelper.error("Message handling error:", error);
      }
    });

    // Guild events
    this.client.on("guildCreate", (guild) => {
      DebugHelper.info(`Joined new guild: ${guild.name} (${guild.id})`);
    });

    this.client.on("guildDelete", (guild) => {
      DebugHelper.info(`Left guild: ${guild.name} (${guild.id})`);
    });

    // Error handling
    this.client.on("error", (error) => {
      DebugHelper.error("Discord.js error:", error);
    });

    this.client.on("warn", (warning) => {
      DebugHelper.warn("Discord.js warning:", warning);
    });

    this.client.rest.on("rateLimited", (rateLimitInfo) => {
      DebugHelper.warn("Rate limited:", rateLimitInfo);
    });
  }

  async handleSlashCommands(interaction) {
    try {
      const { commandName } = interaction;

      DebugHelper.log(
        `Slash command: /${commandName} by ${interaction.user.tag}`
      );

      switch (commandName) {
        case "setup_menu":
          await this.handleSetupMenuCommand(interaction);
          break;
        // ‚ùå ‡πÄ‡∏≠‡∏≤ case ‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å:
        // case "setup_scoreboard":
        //   await this.handleSetupScoreboardCommand(interaction);
        //   break;
        case "test_webhook":
          await this.handleTestWebhookCommand(interaction);
          break;
        case "test_rcon":
          await this.handleTestRconCommand(interaction);
          break;
        case "test_easyslip":
          await this.handleTestEasySlipCommand(interaction);
          break;
        case "bot_status":
          await this.handleBotStatusCommand(interaction);
          break;
        default:
          await ResponseHelper.safeReply(interaction, "‚ùå ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö");
      }
    } catch (error) {
      await ErrorHandler.handleInteractionError(
        error,
        interaction,
        "Slash Command"
      );
    }
  }

  async handleSetupMenuCommand(interaction) {
    if (!interaction.member.permissions.has("Administrator")) {
      return await ResponseHelper.safeReply(
        interaction,
        "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
      );
    }

    await ResponseHelper.safeDefer(interaction);

    try {
      await this.topupSystem.sendMainMenu(interaction.channel);
      await interaction.editReply("‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß");
    } catch (error) {
      await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏ô‡∏π");
    }
  }

  // ‚ùå ‡πÄ‡∏≠‡∏≤ method ‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:
  // async handleSetupScoreboardCommand(interaction) {
  //   if (!interaction.member.permissions.has("Administrator")) {
  //     return await ResponseHelper.safeReply(
  //       interaction,
  //       "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
  //     );
  //   }
  //
  //   await ResponseHelper.safeDefer(interaction);
  //
  //   try {
  //     await this.scoreboardManager.setupPermanentScoreboard(
  //       interaction.channel
  //     );
  //     await interaction.editReply("‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Scoreboard ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß");
  //   } catch (error) {
  //     await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Scoreboard");
  //   }
  // }

  async handleTestWebhookCommand(interaction) {
    if (!interaction.member.permissions.has("Administrator")) {
      return await ResponseHelper.safeReply(
        interaction,
        "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
      );
    }

    await ResponseHelper.safeDefer(interaction);

    try {
      const result = await webhookService.testWebhook();
      const message = result.success
        ? "‚úÖ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö webhook ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"
        : `‚ùå ‡∏ó‡∏î‡∏™‡∏≠‡∏ö webhook ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${result.error}`;

      await interaction.editReply(message);
    } catch (error) {
      await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö webhook");
    }
  }

  async handleTestRconCommand(interaction) {
    if (!interaction.member.permissions.has("Administrator")) {
      return await ResponseHelper.safeReply(
        interaction,
        "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
      );
    }

    await ResponseHelper.safeDefer(interaction);

    try {
      const rconConfig = rconManager.getConfiguration();

      if (rconConfig.totalServers === 0) {
        return await interaction.editReply(
          "‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå RCON ‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏ß‡πâ"
        );
      }

      const testResults = await rconManager.testAllServers();
      const results = Object.entries(testResults.results).map(
        ([serverKey, result]) =>
          `**${serverKey}**: ${
            result.success ? "‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" : `‚ùå ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß (${result.error})`
          }`
      );

      await interaction.editReply(
        `**‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö RCON:**\n${results.join("\n")}`
      );
    } catch (error) {
      await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö RCON");
    }
  }

  async handleTestEasySlipCommand(interaction) {
    if (!interaction.member.permissions.has("Administrator")) {
      return await ResponseHelper.safeReply(
        interaction,
        "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
      );
    }

    await ResponseHelper.safeDefer(interaction);

    try {
      const slipStatus = slipVerification.getServiceStatus();
      const config = configService.get('easyslip', {});
      
      const statusMessage = `
**üîç EasySlip API Status Report:**

üìä **Current Status:** ${slipStatus.enabled ? 'üü¢ ENABLED' : 'üî¥ DISABLED'}
üîë **API Key Status:** ${slipStatus.apiKeyValid ? '‚úÖ Valid' : '‚ùå Invalid/Missing'}
‚öôÔ∏è **Validation Mode:** \`${slipStatus.validationMode}\`
üåê **API URL:** ${slipStatus.apiUrl || 'Not set'}

**üìã Configuration Details:**
\`\`\`json
{
  "enabled": ${config.enabled || false},
  "api_key": "${config.api_key ? config.api_key.substring(0, 10) + '...' : 'NOT_SET'}",
  "api_url": "${config.api_url || 'NOT_SET'}"
}
\`\`\`

**üîß Status Explanation:**
${slipStatus.enabled 
  ? '‚úÖ **EasySlip API Active:** ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÅ‡∏ö‡∏ö‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏ú‡πà‡∏≤‡∏ô API' 
  : '‚ö†Ô∏è **Basic Validation Mode:** ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡πÑ‡∏°‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥)'}

${!slipStatus.enabled ? 
`**üìù ‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:**
1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö \`config/config.json\` ‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô \`easyslip\`
2. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ \`"enabled": true\`
3. ‡πÉ‡∏™‡πà API Key ‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô \`"api_key"\`
4. ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó bot` : ''}
      `;

      await interaction.editReply(statusMessage);
    } catch (error) {
      await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ EasySlip");
    }
  }

  async handleBotStatusCommand(interaction) {
    if (!interaction.member.permissions.has("Administrator")) {
      return await ResponseHelper.safeReply(
        interaction,
        "‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ"
      );
    }

    await ResponseHelper.safeDefer(interaction);

    try {
      const uptime = process.uptime();
      const days = Math.floor(uptime / 86400);
      const hours = Math.floor((uptime % 86400) / 3600);
      const minutes = Math.floor((uptime % 3600) / 60);

      const memoryMB = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
      const rconConfig = rconManager.getConfiguration();
      const webhookStatus = webhookService.getServiceStatus();
      const dbHealth = await databaseService.healthCheck();
      const slipStatus = slipVerification.getServiceStatus();

      const statusMessage = `
**ü§ñ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏≠‡∏ó NEXArk**

‚è±Ô∏è **‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:** ${days}d ${hours}h ${minutes}m
üíæ **‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥:** ${memoryMB} MB
üè† **‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå Discord:** ${this.client.guilds.cache.size} ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
üóÑÔ∏è **‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:** ${dbHealth.connected ? "‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠" : "‚ùå ‡∏Ç‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠"}
üéÆ **RCON ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå:** ${rconConfig.totalServers} ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
üì¢ **Discord Webhook:** ${
        webhookStatus.enabled ? "‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô" : "‚ùå ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"
      }
üßæ **Slip Verification:** ${
        slipStatus.enabled ? "‚úÖ EasySlip API" : "‚ö†Ô∏è Basic Mode"
      }
      `;

      await interaction.editReply(statusMessage);
    } catch (error) {
      await interaction.editReply("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏≠‡∏ó");
    }
  }

  async loginBot() {
    const token = configService.getDiscordToken();
    DebugHelper.info("Logging in to Discord...");
    await this.client.login(token);
  }

  async sendStartupNotification() {
    try {
      const rconConfig = rconManager.getConfiguration();
      const dbHealth = await databaseService.healthCheck();
      const slipStatus = slipVerification.getServiceStatus();

      const notificationData = {
        discordId: this.client.user.id,
        discordUsername: "System",
        steam64: "SYSTEM",
        characterId: "SYSTEM",
        category: "system",
        itemName: "Bot Startup",
        amount: 0,
        server: "ALL",
        status: "completed",
        ticketId: "STARTUP",
        playerName: "System",
        timestamp: new Date().toISOString(),
      };

      await webhookService.sendDonationNotification(notificationData);
    } catch (error) {
      DebugHelper.error("Error sending startup notification:", error);
    }
  }

  async gracefulShutdown() {
    if (this.isShuttingDown) return;

    DebugHelper.info("Initiating graceful shutdown...");
    this.isShuttingDown = true;

    try {
      // Send shutdown notification
      if (webhookService?.getServiceStatus().enabled) {
        await this.sendShutdownNotification();
      }

      // Shutdown systems
      if (this.topupSystem) {
        await this.topupSystem.shutdown();
      }

      // ‚ùå ‡πÄ‡∏≠‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å:
      // if (this.scoreboardManager) {
      //   this.scoreboardManager.shutdown();
      // }

      if (rconManager) {
        await rconManager.shutdown();
      }

      // Close database connection
      if (databaseService) {
        await databaseService.close();
      }

      // Destroy Discord client
      if (this.client) {
        this.client.destroy();
      }

      DebugHelper.info("Graceful shutdown completed");
    } catch (error) {
      DebugHelper.error("Error during shutdown:", error);
    }
  }

  async sendShutdownNotification() {
    try {
      const notificationData = {
        discordId: this.client.user.id,
        discordUsername: "System",
        steam64: "SYSTEM",
        characterId: "SYSTEM",
        category: "system",
        itemName: "Bot Shutdown",
        amount: 0,
        server: "ALL",
        status: "cancelled",
        ticketId: "SHUTDOWN",
        playerName: "System",
        timestamp: new Date().toISOString(),
      };

      await webhookService.sendDonationNotification(notificationData);
    } catch (error) {
      DebugHelper.error("Error sending shutdown notification:", error);
    }
  }
}

// Start the bot
const bot = new DiscordBot();
bot.init();

// Graceful shutdown handlers
process.on("SIGINT", async () => {
  DebugHelper.info("Received SIGINT, shutting down gracefully...");
  await bot.gracefulShutdown();
  process.exit(0);
});

process.on("SIGTERM", async () => {
  DebugHelper.info("Received SIGTERM, shutting down gracefully...");
  await bot.gracefulShutdown();
  process.exit(0);
});

process.on("unhandledRejection", (error) => {
  DebugHelper.error("Unhandled promise rejection:", error);
});

process.on("uncaughtException", (error) => {
  DebugHelper.error("Uncaught exception:", error);
  setTimeout(() => process.exit(1), 1000);
});

export default DiscordBot;